//
//  MessagesInteractor.swift
//  VK Tosters
//
//  Created programmist_np on 30/01/2020.
//  Copyright © 2020 programmist_np. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import SwiftyVK
import SwiftyJSON

class MessagesInteractor: MessagesInteractorProtocol {
    weak var presenter: MessagesPresenterProtocol?
    var responseJSON: JSON = []
    var usersJSON: [JSON] = []
    var myUserJSON: JSON = JSON()
    var conversationsJSON: [JSON] = []
    var unread: Int = 0
    var updates: JSON!
    
    func start() {
        startObservers()
        getConversations()
    }
    
    func startObservers() {
        NotificationCenter.default.addObserver(self, selector: #selector(updateMessages(_:)), name: .onMessagesUpdate, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(updateMessages(_:)), name: .onFriendOffline, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(updateMessages(_:)), name: .onFriendOnline, object: nil)
    }
    
    func getConversations() {
        VK.API.Messages.getConversations([.filter: "all", .count: "200", .extended: "0"])
        .configure(with: Config.init(httpMethod: .GET, language: Language(rawValue: "ru")))
        .onSuccess { response in
            DispatchQueue.global(qos: .utility).async {
                autoreleasepool {
                    self.responseJSON = JSON(response)
                    let firstParse = self.responseJSON["items"].arrayValue
                    self.unread = self.responseJSON["unread_count"].intValue
                    let conversations = firstParse.map { Conversation(JSON: $0) }
                    var userIds: [String] = []
                    for conversation in conversations {
                        userIds.append("\(conversation.peer.localId)")
                    }
                    let userIdsString = userIds.joined(separator:",")
                    self.getMe()
                    self.getUsers(userIds: userIdsString)
                    self.handleResponseMessages(response: self.responseJSON)
                }
            }
        }
        .onError { error in
            DispatchQueue.main.async {
                autoreleasepool {
                    // self.handleResponseMessages(response: nil)
                }
            }
        }
        .send()
    }
    
    @objc func updateMessages(_ notification: Notification) {
        if let userInfo = notification.userInfo {
            if let updates = userInfo["updates"] {
                self.updates = updates as? JSON
                DispatchQueue.global(qos: .utility).async {
                    self.getConversations()
                }
            }
        }
    }
    
    func getUsers(userIds: String) {
        VK.API.Users.get([.userIDs: userIds, .fields: "photo_100, online, last_seen"])
            .configure(with: Config.init(httpMethod: .GET, language: Language(rawValue: "ru")))
            .onSuccess { response in
                let responseJSON = JSON(response)
                self.handleResponseUsers(response: responseJSON)
        }
        .onError { error in
            
        }
        .send()
    }
    
    func getMe() {
        VK.API.Users.get([.fields: "photo_100"])
            .configure(with: Config.init(httpMethod: .GET, language: Language(rawValue: "ru")))
            .onSuccess { response in
                let responseJSON = JSON(response)
                self.handleResponseMyUser(response: responseJSON)
        }
        .onError { error in
            
        }
        .send()
    }
    
    func handleResponseMessages(response: JSON) {
        conversationsJSON = response["items"].arrayValue
    }
    
    func handleResponseUsers(response: JSON) {
        usersJSON = response.arrayValue
        DispatchQueue.main.async {
            self.presenter?.onLoaded()
        }
    }
    
    func handleResponseMyUser(response: JSON) {
        myUserJSON = response
    }
    
    func readMessage(peerId: String) {
        VK.API.Messages.markAsRead([.peerId: peerId])
            .configure(with: Config(httpMethod: .GET, language: Language(rawValue: "ru")))
            .onSuccess { _ in
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: {
                    self.presenter?.onLoaded()
                    self.presenter?.onEvent(message: "Сообщение прочитано", .default)
                    self.presenter?.onLoaded()
                })
            }
        .onError { error in
            DispatchQueue.main.async {
                self.presenter?.onEvent(message: "\(error)", .default)
            }
        }.send()
    }
}
