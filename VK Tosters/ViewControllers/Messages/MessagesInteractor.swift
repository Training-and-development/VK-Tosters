//
//  MessagesInteractor.swift
//  VK Tosters
//
//  Created programmist_np on 30/01/2020.
//  Copyright © 2020 programmist_np. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import SwiftyVK
import SwiftyJSON
import RealmSwift

class MessagesInteractor: MessagesInteractorProtocol {
    weak var presenter: MessagesPresenterProtocol?
    var unread: Int = 0
    
    deinit {
        NotificationCenter.default.removeObserver(self)
        print("MessagesInteractor deinited")
    }
    
    func start() {
        getConversationsFull()
        startObservers()
    }
    
    func startObservers() {
        //NotificationCenter.default.addObserver(self, selector: #selector(receiveMessages(_:)), name: .onMessagesReceived, object: nil)
        //NotificationCenter.default.addObserver(self, selector: #selector(removeMessages(_:)), name: .onMessagesRemoved, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(friendOffline(_:)), name: .onFriendOffline, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(friendOnline(_:)), name: .onFriendOnline, object: nil)
    }
    
    func getConversationsFull() {
        VK.API.Messages.getConversations([.filter: "all", .count: "200", .extended: "1"])
        .configure(with: Config.init(httpMethod: .GET, language: Language(rawValue: "ru")))
        .onSuccess { response in
            DispatchQueue.global(qos: .utility).async {
                autoreleasepool {
                    let responseJSON = JSON(response)
                    let firstParse = responseJSON["items"].arrayValue
                }
            }
        }
        .onError { error in
            self.presenter?.onError(message: "Нет доступа к API", .error)
        }
        .send()
    }
    
    func readMessage(peerId: String) {
        VK.API.Messages.markAsRead([.peerId: peerId])
            .configure(with: Config(httpMethod: .GET, language: Language(rawValue: "ru")))
            .onSuccess { _ in
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2, execute: {
                    self.presenter?.onLoaded()
                    self.presenter?.onEvent(message: "Сообщение прочитано", .default)
                    self.presenter?.onLoaded()
                })
            }
        .onError { error in
            DispatchQueue.main.async {
                self.presenter?.onEvent(message: "\(error)", .default)
            }
        }.send()
    }
    
    @objc func receiveMessages(_ notification: Notification) {
        if let userInfo = notification.userInfo {
            if let updates = userInfo["updates"] {
            }
        }
    }
    
     @objc func friendOnline(_ notification: Notification) {
        if let userInfo = notification.userInfo {
            if let updates = userInfo["updates"] {
                let updates = updates as? JSON
                let realm = try! Realm()
                
                let conversations = realm.objects(DBConversation.self).filter("id = %@", updates![0].intValue * -1)
                print(updates![0].intValue * -1)
                print(conversations)
                
                try! realm.write {
                    conversations.first?.setValue(updates![4].intValue, forKeyPath: "online")
                }
                realm.refresh()
                
                DispatchQueue.main.async {
                    NotificationCenter.default.post(name: NSNotification.Name(rawValue: "RELOAD_NOTIFICATION"), object: nil)
                }
            }
        }
    }
    
     @objc func friendOffline(_ notification: Notification) {
        if let userInfo = notification.userInfo {
            if let updates = userInfo["updates"] {
                let updates = updates as? JSON
                let realm = try! Realm()
                
                let conversations = realm.objects(DBConversation.self).filter("id = %@", updates![0].intValue * -1)
                print(conversations)
                
                try! realm.write {
                    conversations.first?.setValue(updates![4].intValue, forKeyPath: "online")
                }
                realm.refresh()
                
                DispatchQueue.main.async {
                    NotificationCenter.default.post(name: NSNotification.Name(rawValue: "RELOAD_NOTIFICATION"), object: nil)
                }
            }
        }
    }
}
extension JSON {
    mutating func appendIfArray(json: JSON) {
        if var arr = self.array{
            arr.append(json)
            self = JSON(arr)
        }
    }

    mutating func appendIfDictionary(key: String, json: JSON) {
        if var dict = self.dictionary {
            dict[key] = json
            self = JSON(dict)
        }
    }
}
